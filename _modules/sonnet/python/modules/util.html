
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sonnet.python.modules.util &#8212; sonnet git documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sonnet.python.modules.util</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2017 The Sonnet Authors. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>

<span class="sd">&quot;&quot;&quot;Utility functions for dealing with Sonnet Modules.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="c1"># Dependency imports</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">wrapt</span>

<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">function</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="k">import</span> <span class="n">variable_scope</span> <span class="k">as</span> <span class="n">variable_scope_ops</span>


<div class="viewcode-block" id="get_variable_scope_name"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.get_variable_scope_name">[docs]</a><span class="k">def</span> <span class="nf">get_variable_scope_name</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns the name of the variable scope indicated by the given value.</span>

<span class="sd">  Args:</span>
<span class="sd">    value: String, variable scope, or object with `variable_scope` attribute</span>
<span class="sd">    (e.g., Sonnet module).</span>

<span class="sd">  Returns:</span>
<span class="sd">    The name (a string) of the corresponding variable scope.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: If `value` does not identify a variable scope.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># If the object has a &quot;variable_scope&quot; property, use it.</span>
  <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;variable_scope&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">VariableScope</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not a variable scope: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_variables_in_scope"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.get_variables_in_scope">[docs]</a><span class="k">def</span> <span class="nf">get_variables_in_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">GraphKeys</span><span class="o">.</span><span class="n">TRAINABLE_VARIABLES</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a tuple `tf.Variable`s in a scope for a given collection.</span>

<span class="sd">  Args:</span>
<span class="sd">    scope: `tf.VariableScope` or string to retrieve variables from.</span>
<span class="sd">    collection: Collection to restrict query to. By default this is</span>
<span class="sd">        `tf.Graphkeys.TRAINABLE_VARIABLES`, which doesn&#39;t include non-trainable</span>
<span class="sd">        variables such as moving averages.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A tuple of `tf.Variable` objects.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">scope_name</span> <span class="o">=</span> <span class="n">get_variable_scope_name</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">scope_name</span><span class="p">:</span>
    <span class="c1"># Escape the name in case it contains any &quot;.&quot; characters. Add a closing</span>
    <span class="c1"># slash so we will not search any scopes that have this scope name as a</span>
    <span class="c1"># prefix.</span>
    <span class="n">scope_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">scope_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>

  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">scope_name</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_variables_in_module"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.get_variables_in_module">[docs]</a><span class="k">def</span> <span class="nf">get_variables_in_module</span><span class="p">(</span><span class="n">module</span><span class="p">,</span>
                            <span class="n">collection</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">GraphKeys</span><span class="o">.</span><span class="n">TRAINABLE_VARIABLES</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns tuple of `tf.Variable`s declared inside an `snt.Module`.</span>

<span class="sd">  Note that this operates by searching the variable scope a module contains,</span>
<span class="sd">  and so does not know about any modules which were constructed elsewhere but</span>
<span class="sd">  used inside this module.</span>

<span class="sd">  Args:</span>
<span class="sd">    module: `snt.Module` instance to query the scope of.</span>
<span class="sd">    collection: Collection to restrict query to. By default this is</span>
<span class="sd">      `tf.Graphkeys.TRAINABLE_VARIABLES`, which doesn&#39;t include non-trainable</span>
<span class="sd">      variables such as moving averages.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A tuple of `tf.Variable` objects.</span>

<span class="sd">  Raises:</span>
<span class="sd">    NotConnectedError: If the module is not connected to the Graph.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">module</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_check_nested_callables</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">object_name</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks if all items in the dictionary and in subdictionaries are callables.</span>

<span class="sd">  Args:</span>
<span class="sd">    dictionary: Dictionary of callables or other dictionaries with callables.</span>
<span class="sd">    object_name: The name of the object that is expected in the dictionary.</span>
<span class="sd">      E.g. &#39;Initializer&#39;, &#39;Partitioner&#39; or &#39;Regularizer&#39;. The first letter</span>
<span class="sd">      should be capitalised as this will be the first word in the error message.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: If the dictionary contains something that is not either a</span>
<span class="sd">      dictionary or a callable.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
      <span class="n">_check_nested_callables</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">object_name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
          <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> for &#39;</span><span class="si">{}</span><span class="s2">&#39; is not a callable function or dictionary&quot;</span>
          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">object_name</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_assert_is_dictlike</span><span class="p">(</span><span class="n">maybe_dictlike</span><span class="p">,</span> <span class="n">valid_keys</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Raises a TypeError iff `maybe_dictlike` is not a dictlike object.&quot;&quot;&quot;</span>
  <span class="c1"># This covers a common mistake when people use incorrect dictionary nesting</span>
  <span class="c1"># for initializers / partitioners etc. The previous error message was quite</span>
  <span class="c1"># opaque, this should be much clearer.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">maybe_dictlike</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="s2">&quot;Expected a dict-like object with possible keys </span><span class="si">%s</span><span class="s2">, received </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
        <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">valid_keys</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">maybe_dictlike</span><span class="p">)))</span>


<div class="viewcode-block" id="check_initializers"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.check_initializers">[docs]</a><span class="k">def</span> <span class="nf">check_initializers</span><span class="p">(</span><span class="n">initializers</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks the given initializers.</span>

<span class="sd">  This checks that `initializers` is a dictionary that only contains keys in</span>
<span class="sd">  `keys`, and furthermore the entries in `initializers` are functions or</span>
<span class="sd">  further dictionaries (the latter used, for example, in passing initializers</span>
<span class="sd">  to modules inside modules) that must satisfy the same constraints.</span>

<span class="sd">  Args:</span>
<span class="sd">    initializers: Dictionary of initializers (allowing nested dictionaries) or</span>
<span class="sd">      None.</span>
<span class="sd">    keys: Iterable of valid keys for `initializers`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Copy of checked dictionary of initializers. If `initializers=None`, an empty</span>
<span class="sd">    dictionary will be returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    KeyError: If an initializer is provided for a key not in `keys`.</span>
<span class="sd">    TypeError: If a provided initializer is not a callable function, or</span>
<span class="sd">      `initializers` is not a Mapping.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">initializers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{}</span>
  <span class="n">_assert_is_dictlike</span><span class="p">(</span><span class="n">initializers</span><span class="p">,</span> <span class="n">valid_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

  <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">initializers</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">extra_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initializers</span><span class="p">)</span> <span class="o">-</span> <span class="n">keys</span>
    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
        <span class="s2">&quot;Invalid initializer keys </span><span class="si">{}</span><span class="s2">, initializers can only &quot;</span>
        <span class="s2">&quot;be provided for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_keys</span><span class="p">),</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)))</span>

  <span class="n">_check_nested_callables</span><span class="p">(</span><span class="n">initializers</span><span class="p">,</span> <span class="s2">&quot;Initializer&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initializers</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_partitioners"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.check_partitioners">[docs]</a><span class="k">def</span> <span class="nf">check_partitioners</span><span class="p">(</span><span class="n">partitioners</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks the given partitioners.</span>

<span class="sd">  This checks that `partitioners` is a dictionary that only contains keys in</span>
<span class="sd">  `keys`, and furthermore the entries in `partitioners` are functions or</span>
<span class="sd">  further dictionaries (the latter used, for example, in passing partitioners</span>
<span class="sd">  to modules inside modules) that must satisfy the same constraints.</span>

<span class="sd">  Args:</span>
<span class="sd">    partitioners: Dictionary of partitioners (allowing nested dictionaries) or</span>
<span class="sd">        None.</span>
<span class="sd">    keys: Iterable of valid keys for `partitioners`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Checked dictionary of partitioners. If `partitioners=None`, an empty</span>
<span class="sd">    dictionary will be returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    KeyError: If an partitioner is provided for a key not in `keys`.</span>
<span class="sd">    TypeError: If a provided partitioner is not a callable function, or</span>
<span class="sd">      `partitioners` is not a Mapping.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">partitioners</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{}</span>
  <span class="n">_assert_is_dictlike</span><span class="p">(</span><span class="n">partitioners</span><span class="p">,</span> <span class="n">valid_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

  <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">partitioners</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">extra_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">partitioners</span><span class="p">)</span> <span class="o">-</span> <span class="n">keys</span>
    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
        <span class="s2">&quot;Invalid partitioner keys </span><span class="si">{}</span><span class="s2">, partitioners can only &quot;</span>
        <span class="s2">&quot;be provided for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_keys</span><span class="p">),</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)))</span>

  <span class="n">_check_nested_callables</span><span class="p">(</span><span class="n">partitioners</span><span class="p">,</span> <span class="s2">&quot;Partitioner&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">partitioners</span></div>


<div class="viewcode-block" id="check_regularizers"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.check_regularizers">[docs]</a><span class="k">def</span> <span class="nf">check_regularizers</span><span class="p">(</span><span class="n">regularizers</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks the given regularizers.</span>

<span class="sd">  This checks that `regularizers` is a dictionary that only contains keys in</span>
<span class="sd">  `keys`, and furthermore the entries in `regularizers` are functions or</span>
<span class="sd">  further dictionaries (the latter used, for example, in passing regularizers</span>
<span class="sd">  to modules inside modules) that must satisfy the same constraints.</span>

<span class="sd">  Args:</span>
<span class="sd">    regularizers: Dictionary of regularizers (allowing nested dictionaries) or</span>
<span class="sd">      None.</span>
<span class="sd">    keys: Iterable of valid keys for `regularizers`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Copy of checked dictionary of regularizers. If `regularizers=None`, an empty</span>
<span class="sd">    dictionary will be returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    KeyError: If an regularizers is provided for a key not in `keys`.</span>
<span class="sd">    TypeError: If a provided regularizer is not a callable function, or</span>
<span class="sd">      `regularizers` is not a Mapping.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">regularizers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{}</span>
  <span class="n">_assert_is_dictlike</span><span class="p">(</span><span class="n">regularizers</span><span class="p">,</span> <span class="n">valid_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

  <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">regularizers</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">extra_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">regularizers</span><span class="p">)</span> <span class="o">-</span> <span class="n">keys</span>
    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
        <span class="s2">&quot;Invalid regularizer keys </span><span class="si">{}</span><span class="s2">, regularizers can only &quot;</span>
        <span class="s2">&quot;be provided for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_keys</span><span class="p">),</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)))</span>

  <span class="n">_check_nested_callables</span><span class="p">(</span><span class="n">regularizers</span><span class="p">,</span> <span class="s2">&quot;Regularizer&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">regularizers</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_is_scope_prefix</span><span class="p">(</span><span class="n">scope_name</span><span class="p">,</span> <span class="n">prefix_name</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks that `prefix_name` is a proper scope prefix of `scope_name`.&quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix_name</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">scope_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
    <span class="n">scope_name</span> <span class="o">+=</span> <span class="s2">&quot;/&quot;</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
    <span class="n">prefix_name</span> <span class="o">+=</span> <span class="s2">&quot;/&quot;</span>

  <span class="k">return</span> <span class="n">scope_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">)</span>


<span class="c1"># pylint: disable=protected-access</span>
<span class="k">def</span> <span class="nf">_get_sliced_variables</span><span class="p">(</span><span class="n">var_list</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Separates the sliced (partitioned) and unsliced variables in var_list.</span>

<span class="sd">  Args:</span>
<span class="sd">    var_list: a list of variables.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A list of unsliced variables in var_list, and a dict mapping names to parts</span>
<span class="sd">    for the sliced variables in var_list.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">unsliced_variables</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">sliced_variables</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>
  <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">var_list</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">_save_slice_info</span><span class="p">:</span>
      <span class="n">sliced_variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">_save_slice_info</span><span class="o">.</span><span class="n">full_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">unsliced_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">unsliced_variables</span><span class="p">,</span> <span class="n">sliced_variables</span>
<span class="c1"># pylint: enable=protected-access</span>


<div class="viewcode-block" id="custom_getter_router"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.custom_getter_router">[docs]</a><span class="k">def</span> <span class="nf">custom_getter_router</span><span class="p">(</span><span class="n">custom_getter_map</span><span class="p">,</span> <span class="n">name_fn</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Creates a custom getter than matches requests to dict of custom getters.</span>

<span class="sd">  Custom getters are callables which implement the</span>
<span class="sd">  [custom getter API]</span>
<span class="sd">  (https://www.tensorflow.org/versions/r1.0/api_docs/python/tf/get_variable).</span>

<span class="sd">  The returned custom getter dispatches calls based on pattern matching the</span>
<span class="sd">  name of the requested variable to the keys of custom_getter_map. For example,</span>

<span class="sd">      {</span>
<span class="sd">        &quot;.*/w&quot;: snt.custom_getters.stop_gradient,</span>
<span class="sd">      }</span>

<span class="sd">  will match all variables named with the suffix &quot;/w&quot;. The `name_fn` is</span>
<span class="sd">  provided to allow processing of the name, such as stripping off a scope prefix</span>
<span class="sd">  before matching.</span>

<span class="sd">  Args:</span>
<span class="sd">    custom_getter_map: Mapping of regular expressions to custom getter</span>
<span class="sd">      functions.</span>
<span class="sd">    name_fn: Callable to map variable name through before matching to regular</span>
<span class="sd">      expressions. This might, for example, strip off a scope prefix.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A custom getter.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: If an entry in `custom_getter_map` is not a callable function.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">for</span> <span class="n">custom_getter</span> <span class="ow">in</span> <span class="n">custom_getter_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">custom_getter</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Given custom_getter is not callable.&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_custom_getter</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A custom getter that routes based on pattern matching the variable name.</span>

<span class="sd">    Args:</span>
<span class="sd">      getter: The true getter to call.</span>
<span class="sd">      name: The fully qualified variable name, i.e. including all scopes.</span>
<span class="sd">      *args: Arguments, in the same format as tf.get_variable.</span>
<span class="sd">      **kwargs: Keyword arguments, in the same format as tf.get_variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      The return value of the appropriate custom getter. If there are no</span>
<span class="sd">      matches, it returns the return value of `getter`.</span>

<span class="sd">    Raises:</span>
<span class="sd">      KeyError: If more than one pattern matches the variable name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bare_name</span> <span class="o">=</span> <span class="n">name_fn</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">custom_getter</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">custom_getter</span> <span class="ow">in</span> <span class="n">custom_getter_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">bare_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">num_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_matches</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">getter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">num_matches</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">custom_getter</span><span class="p">,</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">custom_getter</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;More than one custom_getter matched </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
          <span class="n">name</span><span class="p">,</span> <span class="n">bare_name</span><span class="p">,</span> <span class="p">[</span><span class="n">pattern</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]))</span>

  <span class="k">return</span> <span class="n">_custom_getter</span></div>


<div class="viewcode-block" id="get_normalized_variable_map"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.get_normalized_variable_map">[docs]</a><span class="k">def</span> <span class="nf">get_normalized_variable_map</span><span class="p">(</span><span class="n">scope_or_module</span><span class="p">,</span>
                                <span class="n">collection</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">GraphKeys</span><span class="o">.</span><span class="n">GLOBAL_VARIABLES</span><span class="p">,</span>
                                <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">group_sliced_variables</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Builds map of `tf.Variable`s in scope or module with normalized names.</span>

<span class="sd">  The names of the variables are normalized to remove the scope prefix.</span>

<span class="sd">  Args:</span>
<span class="sd">    scope_or_module: Scope or module to build map from.</span>
<span class="sd">    collection: Collection to restrict query to. By default this is</span>
<span class="sd">        `tf.Graphkeys.GLOBAL_VARIABLES`, which includes non-trainable variables</span>
<span class="sd">        such as moving averages.</span>
<span class="sd">    context: Scope or module, identical to or parent of `scope`. If given, this</span>
<span class="sd">        will be used as the stripped prefix. By default `None`, which means</span>
<span class="sd">        `context=scope`.</span>
<span class="sd">    group_sliced_variables: Boolean, if set to True, sliced variables are</span>
<span class="sd">       grouped together in the returned map; if set to False, each partition of</span>
<span class="sd">       a sliced variable is a separate (key, value) pair.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Dictionary mapping normalized variable name to `tf.Variable`, or a list</span>
<span class="sd">        of `tf.Variables` if the variable is a sliced (partitioned) variable.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: If `context` is given but is not a proper prefix of `scope`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">scope_name</span> <span class="o">=</span> <span class="n">get_variable_scope_name</span><span class="p">(</span><span class="n">scope_or_module</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">context</span> <span class="o">=</span> <span class="n">scope_or_module</span>

  <span class="n">prefix</span> <span class="o">=</span> <span class="n">get_variable_scope_name</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
  <span class="n">prefix_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="mi">0</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_scope_prefix</span><span class="p">(</span><span class="n">scope_name</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scope &#39;</span><span class="si">{}</span><span class="s2">&#39; is not prefixed by &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">scope_name</span><span class="p">,</span> <span class="n">prefix</span><span class="p">))</span>

  <span class="n">variables</span> <span class="o">=</span> <span class="n">get_variables_in_scope</span><span class="p">(</span><span class="n">scope_name</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">group_sliced_variables</span><span class="p">:</span>
    <span class="n">single_vars</span> <span class="o">=</span> <span class="n">variables</span>
    <span class="n">grouped_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">single_vars</span><span class="p">,</span> <span class="n">grouped_vars</span> <span class="o">=</span> <span class="n">_get_sliced_variables</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

  <span class="n">var_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">prefix_length</span><span class="p">:]:</span> <span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">single_vars</span><span class="p">}</span>
  <span class="k">for</span> <span class="n">full_name</span><span class="p">,</span> <span class="n">var_group</span> <span class="ow">in</span> <span class="n">grouped_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">full_name</span><span class="p">[</span><span class="n">prefix_length</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">var_map</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mixing slices and non-slices with the same name: &quot;</span> <span class="o">+</span>
                       <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="n">var_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_group</span>
  <span class="k">return</span> <span class="n">var_map</span></div>


<div class="viewcode-block" id="get_saver"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.get_saver">[docs]</a><span class="k">def</span> <span class="nf">get_saver</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">collections</span><span class="o">=</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">GraphKeys</span><span class="o">.</span><span class="n">GLOBAL_VARIABLES</span><span class="p">,),</span>  <span class="c1"># pylint: disable=redefined-outer-name</span>
              <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Builds a `tf.train.Saver` for the scope or module, with normalized names.</span>

<span class="sd">  The names of the variables are normalized to remove the scope prefix.</span>
<span class="sd">  This allows the same variables to be restored into another similar scope or</span>
<span class="sd">  module using a complementary `tf.train.Saver` object.</span>

<span class="sd">  Args:</span>
<span class="sd">    scope: Scope or module. Variables within will be saved or restored.</span>
<span class="sd">    collections: Sequence of collections of variables to restrict</span>
<span class="sd">        `tf.train.Saver` to. By default this is `tf.GraphKeys.GLOBAL_VARIABLES`</span>
<span class="sd">        which includes moving averages variables as well as trainable variables.</span>
<span class="sd">    context: Scope or module, identical to or parent of `scope`. If given, this</span>
<span class="sd">        will be used as the stripped prefix.</span>
<span class="sd">    **kwargs: Extra keyword arguments to pass to tf.train.Saver.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A `tf.train.Saver` object for Variables in the scope or module.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">variable_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">collection</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">:</span>
    <span class="n">variable_map</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_normalized_variable_map</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">Saver</span><span class="p">(</span><span class="n">var_list</span><span class="o">=</span><span class="n">variable_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="has_variable_scope"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.has_variable_scope">[docs]</a><span class="k">def</span> <span class="nf">has_variable_scope</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Determines whether the given object has a variable scope.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="s2">&quot;variable_scope&quot;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_format_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">join_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="n">format_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
  <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
    <span class="n">column_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span>
    <span class="n">format_str</span> <span class="o">+=</span> <span class="s2">&quot;{:&lt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">column_width</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}  &quot;</span>

  <span class="n">output_rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span>
  <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_rows</span><span class="p">)</span> <span class="k">if</span> <span class="n">join_lines</span> <span class="k">else</span> <span class="n">output_rows</span>


<div class="viewcode-block" id="variable_map_items"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.variable_map_items">[docs]</a><span class="k">def</span> <span class="nf">variable_map_items</span><span class="p">(</span><span class="n">variable_map</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Yields an iterator over (string, variable) pairs in the variable map.</span>

<span class="sd">  In general, variable maps map variable names to either a `tf.Variable`, or</span>
<span class="sd">  list of `tf.Variable`s (in case of sliced variables).</span>

<span class="sd">  Args:</span>
<span class="sd">    variable_map: dict, variable map over which to iterate.</span>

<span class="sd">  Yields:</span>
<span class="sd">    (string, tf.Variable) pairs.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var_or_vars</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">variable_map</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_or_vars</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">var_or_vars</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">variable</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">var_or_vars</span></div>


<span class="k">def</span> <span class="nf">_get_vars_to_collections</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a dict mapping variables to the collections they appear in.&quot;&quot;&quot;</span>
  <span class="n">var_to_collections</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variable_map_items</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">graph</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">collection_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">collections</span><span class="p">):</span>
      <span class="n">entries</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">collection_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">))</span>
      <span class="c1"># For legacy reasons, tf.GraphKeys.GLOBAL_VARIABLES == &quot;variables&quot;.</span>
      <span class="c1"># Correcting for this here, to avoid confusion.</span>
      <span class="k">if</span> <span class="n">collection_name</span> <span class="o">==</span> <span class="n">tf</span><span class="o">.</span><span class="n">GraphKeys</span><span class="o">.</span><span class="n">GLOBAL_VARIABLES</span><span class="p">:</span>
        <span class="n">collection_name</span> <span class="o">=</span> <span class="s2">&quot;global_variables&quot;</span>
      <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">entries</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
        <span class="n">var_to_collections</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collection_name</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">var_to_collections</span>


<div class="viewcode-block" id="format_variables"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.format_variables">[docs]</a><span class="k">def</span> <span class="nf">format_variables</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">join_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Takes a collection of variables and formats it as a table.&quot;&quot;&quot;</span>
  <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="s2">&quot;Shape&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="s2">&quot;Collections&quot;</span><span class="p">,</span> <span class="s2">&quot;Device&quot;</span><span class="p">))</span>
  <span class="n">var_to_collections</span> <span class="o">=</span> <span class="n">_get_vars_to_collections</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">var</span><span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">is_fully_defined</span><span class="p">():</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">as_list</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot;undefined&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;tf.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">coll</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">var_to_collections</span><span class="p">[</span><span class="n">var</span><span class="p">]))</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">coll</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">_format_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">join_lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="format_variable_map"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.format_variable_map">[docs]</a><span class="k">def</span> <span class="nf">format_variable_map</span><span class="p">(</span><span class="n">variable_map</span><span class="p">,</span> <span class="n">join_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Takes a key-to-variable map and formats it as a table.&quot;&quot;&quot;</span>
  <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;Key&quot;</span><span class="p">,</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="s2">&quot;Shape&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="s2">&quot;Collections&quot;</span><span class="p">,</span> <span class="s2">&quot;Device&quot;</span><span class="p">))</span>
  <span class="n">var_to_collections</span> <span class="o">=</span> <span class="n">_get_vars_to_collections</span><span class="p">(</span><span class="n">variable_map</span><span class="p">)</span>

  <span class="n">sort_key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">variable_map_items</span><span class="p">(</span><span class="n">variable_map</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">as_list</span><span class="p">())</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;tf.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">coll</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">var_to_collections</span><span class="p">[</span><span class="n">var</span><span class="p">]))</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">coll</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">_format_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">join_lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="log_variables"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.log_variables">[docs]</a><span class="k">def</span> <span class="nf">log_variables</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Logs variable information.</span>

<span class="sd">  This function logs the name, shape, type, collections, and device for either</span>
<span class="sd">  all variables or a given iterable of variables.</span>

<span class="sd">  Args:</span>
<span class="sd">    variables: iterable of variables; if not provided, then all variables</span>
<span class="sd">        (in the default graph) are logged.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">global_variables</span><span class="p">()</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">local_variables</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">format_variables</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">join_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">row</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_num_bytes_to_human_readable</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns human readable string of how much memory `num_bytes` fills.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> B&quot;</span> <span class="o">%</span> <span class="n">num_bytes</span>
  <span class="k">elif</span> <span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2"> KB&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2"> MB&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2"> GB&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">))</span>


<div class="viewcode-block" id="summarize_variables"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.summarize_variables">[docs]</a><span class="k">def</span> <span class="nf">summarize_variables</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Logs a summary of variable information.</span>

<span class="sd">  This function groups Variables by dtype and prints out the number of Variables</span>
<span class="sd">  and the total number of scalar values for each datatype, as well as the total</span>
<span class="sd">  memory consumed.</span>

<span class="sd">  For Variables of type tf.string, the memory usage cannot be accurately</span>
<span class="sd">  calculated from the Graph as the memory requirements change based on what</span>
<span class="sd">  strings are actually stored, which can only be determined inside a session.</span>
<span class="sd">  In this case, the amount of memory used to stored the pointers to the strings</span>
<span class="sd">  is logged, along with a warning.</span>

<span class="sd">  Args:</span>
<span class="sd">    variables: iterable of variables; if not provided, then all variables</span>
<span class="sd">      (in the default graph) are summarized.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">variable_counts</span> <span class="o">=</span> <span class="n">count_variables_by_type</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">)</span>
  <span class="n">total_num_scalars</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">total_num_bytes</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Sort by string representation of type name, so output is deterministic.</span>
  <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">variable_counts</span><span class="p">,</span>
                      <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="n">var_info_for_type</span> <span class="o">=</span> <span class="n">variable_counts</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
    <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">var_info_for_type</span><span class="p">[</span><span class="s2">&quot;num_scalars&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">dtype</span><span class="o">.</span><span class="n">size</span>
    <span class="n">total_num_scalars</span> <span class="o">+=</span> <span class="n">var_info_for_type</span><span class="p">[</span><span class="s2">&quot;num_scalars&quot;</span><span class="p">]</span>
    <span class="n">total_num_bytes</span> <span class="o">+=</span> <span class="n">num_bytes</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">: </span><span class="si">%d</span><span class="s2"> variables comprising </span><span class="si">%d</span><span class="s2"> scalars, </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="p">,</span> <span class="n">var_info_for_type</span><span class="p">[</span><span class="s2">&quot;num_variables&quot;</span><span class="p">],</span>
                    <span class="n">var_info_for_type</span><span class="p">[</span><span class="s2">&quot;num_scalars&quot;</span><span class="p">],</span>
                    <span class="n">_num_bytes_to_human_readable</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">))</span></div>


<div class="viewcode-block" id="count_variables_by_type"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.count_variables_by_type">[docs]</a><span class="k">def</span> <span class="nf">count_variables_by_type</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a dict mapping dtypes to number of variables and scalars.</span>

<span class="sd">  Args:</span>
<span class="sd">    variables: iterable of `tf.Variable`s, or None. If None is passed, then all</span>
<span class="sd">      global and local variables in the current graph are used.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A dict mapping tf.dtype keys to a dict containing the keys &#39;num_scalars&#39; and</span>
<span class="sd">      &#39;num_variables&#39;.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">global_variables</span><span class="p">()</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">local_variables</span><span class="p">()</span>
  <span class="n">unique_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span>
  <span class="n">results_dict</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">unique_types</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">:</span>
      <span class="n">tf</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
          <span class="s2">&quot;NB: string Variables present. The memory usage for these  Variables &quot;</span>
          <span class="s2">&quot;will not be accurately computed as it depends on the exact strings &quot;</span>
          <span class="s2">&quot;stored in a particular session.&quot;</span><span class="p">)</span>
    <span class="n">vars_of_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">]</span>
    <span class="n">num_scalars</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_of_type</span><span class="p">)</span>
    <span class="n">results_dict</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;num_variables&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_of_type</span><span class="p">),</span>
        <span class="s2">&quot;num_scalars&quot;</span><span class="p">:</span> <span class="n">num_scalars</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="n">results_dict</span></div>


<div class="viewcode-block" id="reuse_variables"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.reuse_variables">[docs]</a><span class="k">def</span> <span class="nf">reuse_variables</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Wraps an arbitrary method so it does variable sharing.</span>

<span class="sd">  This decorator creates variables the first time it calls `method`, and reuses</span>
<span class="sd">  them for subsequent calls. The object that calls `method` provides a</span>
<span class="sd">  `tf.VariableScope`, either as a `variable_scope` attribute or as the return</span>
<span class="sd">  value of an `_enter_variable_scope()` method.</span>

<span class="sd">  The first time the wrapped method is invoked, it enters the caller&#39;s</span>
<span class="sd">  `tf.VariableScope` with `reuse=False`. On all subsequent calls it enters the</span>
<span class="sd">  same variable scope with `reuse=True`.</span>

<span class="sd">  Variables are created in the context of the `tf.VariableScope` provided by the</span>
<span class="sd">  caller object. Ops are created with an additional `tf.name_scope()`, which</span>
<span class="sd">  adds a scope for the wrapped method name. For example:</span>

<span class="sd">  ```python</span>
<span class="sd">  class MyClass(object):</span>

<span class="sd">    def __init__(self, name):</span>
<span class="sd">      with tf.variable_scope(None, default_name=name) as variable_scope:</span>
<span class="sd">        self.variable_scope = variable_scope</span>

<span class="sd">    @snt.reuse_variables</span>
<span class="sd">    def add_x(self, tensor):</span>
<span class="sd">      x = tf.get_variable(&quot;x&quot;, shape=tensor.get_shape())</span>
<span class="sd">      return tensor + x</span>

<span class="sd">  module = MyClass(&quot;my_module_name&quot;)</span>
<span class="sd">  input_tensor = tf.zeros(shape=(5,))</span>

<span class="sd">  # This creates the variable &quot;my_module_name/x&quot;</span>
<span class="sd">  # and op &quot;my_module_name/add_x/add&quot;</span>
<span class="sd">  output = module.add_x(input_tensor)</span>
<span class="sd">  ```</span>

<span class="sd">  For performance when executing eagerly it may be desirable to additionally</span>
<span class="sd">  annotate these methods using `defun`, such that they are encapsulated as</span>
<span class="sd">  graph functions. This is not recommended if your method returns a variable</span>
<span class="sd">  since the output of `defun` would be an op that returned the variable&#39;s value</span>
<span class="sd">  when evaluated (rather than the variable instance).</span>

<span class="sd">  ```python</span>
<span class="sd">  class FooModule(snt.AbstractModule):</span>
<span class="sd">    def _build(self, inputs):</span>
<span class="sd">      return complex_math(inputs)</span>

<span class="sd">    @tfe.defun</span>
<span class="sd">    @snt.reuse_variables</span>
<span class="sd">    def more_complex_stuff(self, inputs):</span>
<span class="sd">      return more_complex_math(inputs)</span>
<span class="sd">  ```</span>

<span class="sd">  Args:</span>
<span class="sd">    method: The method to wrap.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The wrapped method.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">initialized_variable_scopes_eager</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="n">initialized_variable_scopes_graph</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>

  <span class="c1"># Ensure that the argument passed in is really a method by checking that the</span>
  <span class="c1"># first positional argument to it is &quot;self&quot;.</span>
  <span class="n">arg_spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
  <span class="n">is_method</span> <span class="o">=</span> <span class="n">arg_spec</span><span class="o">.</span><span class="n">args</span> <span class="ow">and</span> <span class="n">arg_spec</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;self&quot;</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">is_method</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;reuse_variables can only be used with methods.&quot;</span><span class="p">)</span>

  <span class="nd">@wrapt</span><span class="o">.</span><span class="n">decorator</span>
  <span class="k">def</span> <span class="nf">eager_test</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validates runtime state in eager mode.&quot;&quot;&quot;</span>
    <span class="c1"># If @reuse_variables is combined with @property, obj is passed in args</span>
    <span class="c1"># and method is still unbound at this stage.</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_template&quot;</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
          <span class="s2">&quot;reuse_variables is not supported in eager mode except in Sonnet &quot;</span>
          <span class="s2">&quot;modules.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="nd">@wrapt</span><span class="o">.</span><span class="n">decorator</span>
  <span class="k">def</span> <span class="nf">call_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calls `method` with a variable scope whose reuse flag is set correctly.</span>

<span class="sd">    The first time the wrapper is called it creates a</span>
<span class="sd">    `(tf.Graph, tf.VariableScope)` key and checks it for membership in</span>
<span class="sd">    `initialized_variable_scopes`. The check is `False` if and only if this is</span>
<span class="sd">    the first time the wrapper has been called with the key, otherwise the</span>
<span class="sd">    check is `True`. The result of this check is used as the `reuse` flag for</span>
<span class="sd">    entering the provided variable scope before calling `method`.</span>

<span class="sd">    Here are two examples of how to use the reuse_variables decorator.</span>

<span class="sd">    1. Decorate an arbitrary instance method with a `variable_scope` attribute:</span>

<span class="sd">      ```python</span>
<span class="sd">      class Reusable(object):</span>

<span class="sd">        def __init__(self, name):</span>
<span class="sd">          with tf.variable_scope(None, default_name=name) as vs:</span>
<span class="sd">            self.variable_scope = vs</span>

<span class="sd">        @snt.reuse_variables</span>
<span class="sd">        def add_a(self, input_tensor):</span>
<span class="sd">          a = tf.get_variable(&quot;a&quot;, shape=input_tensor.get_shape())</span>
<span class="sd">          return a + input_tensor</span>

<span class="sd">      obj = Reusable(&quot;reusable&quot;)</span>
<span class="sd">      x = tf.constant(5.0)</span>
<span class="sd">      out1 = obj.add_a(x)</span>
<span class="sd">      out2 = obj.add_a(x)</span>
<span class="sd">      # out1 == out2</span>
<span class="sd">      ```</span>

<span class="sd">    2. Decorating a snt.AbstractModule instance method:</span>

<span class="sd">      ```python</span>
<span class="sd">      class ReusableModule(snt.AbstractModule):</span>

<span class="sd">        @snt.reuse_variables</span>
<span class="sd">        def add_a(self, input_tensor):</span>
<span class="sd">          a = tf.get_variable(&quot;a&quot;, shape=input_tensor.get_shape())</span>
<span class="sd">          return a + input_tensor</span>

<span class="sd">        # We don&#39;t need @snt.reuse_variables here because build is</span>
<span class="sd">        wrapped by # `tf.make_template` inside `snt.AbstractModule`.</span>
<span class="sd">        def _build(self, input_tensor):</span>
<span class="sd">          b = tf.get_variable(&quot;b&quot;, shape=input_tensor.get_shape())</span>
<span class="sd">          return b + self.add_a(input_tensor)</span>

<span class="sd">      obj = Reusable(&quot;reusable&quot;)</span>
<span class="sd">      x = tf.constant(5.0)</span>
<span class="sd">      out1 = obj(x)</span>
<span class="sd">      out2 = obj(x)</span>
<span class="sd">      # out1 == out2</span>
<span class="sd">      ```</span>

<span class="sd">    Args:</span>
<span class="sd">      method: The method to wrap.</span>
<span class="sd">      obj: The object instance passed to the wrapped method.</span>
<span class="sd">      args: The positional arguments (Tensors) passed to the wrapped method.</span>
<span class="sd">      kwargs: The keyword arguments passed to the wrapped method.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Output of the wrapped method.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If no variable scope is provided or if `method` is a method</span>
<span class="sd">                  and a variable_scope keyword argument is also provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># If @reuse_variables is combined with @property, obj is passed in args</span>
    <span class="c1"># and method is still unbound at this stage.</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">default_context_manager</span><span class="p">(</span><span class="n">reuse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="n">variable_scope</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">variable_scope</span>
      <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="n">variable_scope</span><span class="p">,</span> <span class="n">reuse</span><span class="o">=</span><span class="n">reuse</span><span class="p">)</span>

    <span class="n">variable_scope_context_manager</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_enter_variable_scope&quot;</span><span class="p">,</span>
                                             <span class="n">default_context_manager</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">init_scope</span><span class="p">():</span>
      <span class="c1"># We need `init_scope` incase we&#39;re running inside a defun. In that case</span>
      <span class="c1"># what we want is information about where the function will be called not</span>
      <span class="c1"># where the function is being built.</span>
      <span class="n">graph</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_default_graph</span><span class="p">()</span>
      <span class="n">will_call_in_eager_context</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">will_call_in_eager_context</span><span class="p">:</span>
      <span class="n">initialized_variable_scopes</span> <span class="o">=</span> <span class="n">initialized_variable_scopes_eager</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">graph</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initialized_variable_scopes_graph</span><span class="p">:</span>
        <span class="n">initialized_variable_scopes_graph</span><span class="p">[</span><span class="n">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="n">initialized_variable_scopes</span> <span class="o">=</span> <span class="n">initialized_variable_scopes_graph</span><span class="p">[</span><span class="n">graph</span><span class="p">]</span>

    <span class="c1"># Temporarily enter the variable scope to capture it</span>
    <span class="k">with</span> <span class="n">variable_scope_context_manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp_variable_scope</span><span class="p">:</span>
      <span class="n">variable_scope</span> <span class="o">=</span> <span class="n">tmp_variable_scope</span>

    <span class="n">reuse</span> <span class="o">=</span> <span class="n">variable_scope</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">initialized_variable_scopes</span>

    <span class="c1"># Enter the pure variable scope with reuse correctly set</span>
    <span class="k">with</span> <span class="n">variable_scope_ops</span><span class="o">.</span><span class="n">_pure_variable_scope</span><span class="p">(</span>  <span class="c1"># pylint:disable=protected-access</span>
        <span class="n">variable_scope</span><span class="p">,</span> <span class="n">reuse</span><span class="o">=</span><span class="n">reuse</span><span class="p">)</span> <span class="k">as</span> <span class="n">pure_variable_scope</span><span class="p">:</span>
      <span class="n">current_name_scope</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_default_graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_name_scope</span><span class="p">()</span>
      <span class="c1"># Force tf.name_scope to treat current_name_scope as an &quot;absolute&quot; scope</span>
      <span class="c1"># so we can re-enter it.</span>
      <span class="k">if</span> <span class="n">current_name_scope</span> <span class="ow">and</span> <span class="n">current_name_scope</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
        <span class="n">current_name_scope</span> <span class="o">+=</span> <span class="s2">&quot;/&quot;</span>
      <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">current_name_scope</span><span class="p">):</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="n">pure_variable_scope</span><span class="o">.</span><span class="n">name</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">to_snake_case</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">method_name_scope</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">method_name_scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">scope</span><span class="p">:</span>
          <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_capture_variables&quot;</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">obj</span><span class="o">.</span><span class="n">_capture_variables</span><span class="p">():</span>  <span class="c1"># pylint: disable=protected-access</span>
              <span class="n">out_ops</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">out_ops</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="n">initialized_variable_scopes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pure_variable_scope</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="c1"># If `obj` is a Sonnet module, let it know it&#39;s been connected</span>
        <span class="c1"># to the TF graph.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_connected</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tf</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
          <span class="n">obj</span><span class="o">.</span><span class="n">_add_connected_subgraph</span><span class="p">(</span>  <span class="c1"># pylint: disable=protected-access</span>
              <span class="n">method</span><span class="p">,</span> <span class="n">out_ops</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">out_ops</span>

  <span class="k">return</span> <span class="n">eager_test</span><span class="p">(</span><span class="n">call_method</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>  <span class="c1"># pylint: disable=no-value-for-parameter</span></div>


<div class="viewcode-block" id="name_for_callable"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.name_for_callable">[docs]</a><span class="k">def</span> <span class="nf">name_for_callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a module name for a callable or `None` if no name can be found.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">name_for_callable</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">to_snake_case</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="to_snake_case"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.to_snake_case">[docs]</a><span class="k">def</span> <span class="nf">to_snake_case</span><span class="p">(</span><span class="n">camel_case</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a CamelCase string as a snake_case string.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[A-Za-z_]\w*$&quot;</span><span class="p">,</span> <span class="n">camel_case</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;Input string </span><span class="si">%s</span><span class="s2"> is not a valid Python identifier.&quot;</span> <span class="o">%</span> <span class="n">camel_case</span><span class="p">)</span>

  <span class="c1"># Add underscore at word start and ends.</span>
  <span class="n">underscored</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([A-Z][a-z])&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;_\1&quot;</span><span class="p">,</span> <span class="n">camel_case</span><span class="p">)</span>
  <span class="n">underscored</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([a-z])([A-Z])&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">underscored</span><span class="p">)</span>
  <span class="c1"># Add underscore before alphanumeric chunks.</span>
  <span class="n">underscored</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([a-z])([0-9][^_]*)&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">underscored</span><span class="p">)</span>
  <span class="c1"># Remove any underscores at start or end of name and convert to lowercase.</span>
  <span class="k">return</span> <span class="n">underscored</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>


<span class="nd">@function</span><span class="o">.</span><span class="n">Defun</span><span class="p">(</span>
    <span class="n">python_grad_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">dy</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">dy</span><span class="p">),</span>
    <span class="n">shape_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()])</span>
<span class="k">def</span> <span class="nf">convert_gradient_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Identity operation whose gradient is converted to a `Tensor`.</span>

<span class="sd">  Currently, the gradient to `tf.concat` is particularly expensive to</span>
<span class="sd">  compute if dy is an `IndexedSlices` (a lack of GPU implementation</span>
<span class="sd">  forces the gradient operation onto CPU).  This situation occurs when</span>
<span class="sd">  the output of the `tf.concat` is eventually passed to `tf.gather`.</span>
<span class="sd">  It is sometimes faster to convert the gradient to a `Tensor`, so as</span>
<span class="sd">  to get the cheaper gradient for `tf.concat`.  To do this, replace</span>
<span class="sd">  `tf.concat(x)` with `convert_gradient_to_tensor(tf.concat(x))`.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: A `Tensor`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The input `Tensor`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="sort_by_name"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.sort_by_name">[docs]</a><span class="k">def</span> <span class="nf">sort_by_name</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a tuple of `variables` sorted ascending by name.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))</span></div>


<div class="viewcode-block" id="notify_about_variables"><a class="viewcode-back" href="../../../../api/sonnet.python.modules.html#sonnet.python.modules.util.notify_about_variables">[docs]</a><span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">notify_about_variables</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Calls `callback(var)` for all `tf.{Variable,get_variable}` results.</span>

<span class="sd">  Callback should not modify the variable passed in. Use cases that require</span>
<span class="sd">  variables to be modified should use `variable_creator_scope` directly and sit</span>
<span class="sd">  within the variable creator stack.</span>

<span class="sd">  &gt;&gt;&gt; variables = []</span>
<span class="sd">  &gt;&gt;&gt; with notify_about_variables(variables.append):</span>
<span class="sd">  ...   v = tf.Variable(1.0, name=&#39;v&#39;)</span>
<span class="sd">  ...   w = tf.get_variable(&#39;w&#39;, [])</span>
<span class="sd">  &gt;&gt;&gt; assert variables == [v, w]</span>

<span class="sd">  Args:</span>
<span class="sd">    callback: a callable taking a single argument which is a tf.Variable.</span>

<span class="sd">  Yields:</span>
<span class="sd">    `None` - used for contextmanager API.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_tracking_creator</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">getter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>

  <span class="k">with</span> <span class="n">variable_scope_ops</span><span class="o">.</span><span class="n">variable_creator_scope</span><span class="p">(</span><span class="n">_tracking_creator</span><span class="p">):</span>
    <span class="k">yield</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">sonnet</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Sonnet Authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>